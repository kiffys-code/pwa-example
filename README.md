# About

This is a very simple example of making an offline-first app that listens for updates, built using the pwa template
with Create React App. 

The goal was to build something using the service worker files generated by the templte, without
modifying them to our purposes. The example here does the following:

  - checks for updates in the background
  - shows an "update available" message when updates are available
  - allows the user to manually check for updates and displays a "no update found" message or triggers the above "update available" message
  - displays an "app available offline" message after service workers have been activated
  - above is resilient to page refreshes

It builds on https://betterprogramming.pub/let-users-know-when-you-have-updated-your-service-worker-in-create-react-app-b0c2701995b3 by making behavior consistent across page refreshes.

Other great sources include https://web.dev/articles/service-worker-lifecycle and https://web.dev/learn/pwa/service-workers for learning the basics about service workers and how to understand the developer tool service-worker features in Chrome.

# Running / Verifying

Service workers are only activated in a prod build. You can serve the app with:

```
npm ci
npm run build-and-serve
```

If you open the app in an Incognito tab (for developer's sanity!), you should see the "app available offline" message. If you refresh the page, it should still show up!

Then, you can take down the server, change the code (e.g. increment the "version" string in App.js), and watch the app while the server starts back up. You should see the "updated available" message pop up on its own, and after soft-refreshing it should pop up after a second. If you're fast, you can click the check for updates button and it'll popup right away. Soft-refresh the page and it'll all work the same way.

(I'm being lazy and letting the update interval do the update, but you could ofc just call checkForUpdates in an effect if you wanted it to check immediately on app load, when changing routes, etc)

Ofc, if you click the "install update" button then you should see your new update install and the "app available offline" message. Soft-refresh the page and you'll still see the new app and the "app available offline" message.

# Lessons Learned

**First lesson learned**: The main problem I encountered with lots of the examples online is that if you (soft) refreshed the page then the "update available" etc messages wouldn't pop up again. The was especially a problem in PWAs sometimes if they'd been inactive for a while, you'd restarted your phone, etc. You had to *hard* refresh (not always possible for PWAs natively) and I didn't understand why...

The biggest lesson here was learning that the callbacks made available in the template service-worker files only run after initial installation of the service worker (just look at their code)...They're not going to fire again for service workers already activated or when you have one installed and waiting to be activated. Hard refreshes worked because hard refreshes remove existing service workers and puts them through that new install process all over again.

So, to solve this problem I needed to grab the state of that directly with the `navigator.serviceWorker` API to synchronize that with the app state. This specifically was to add the registered service worker if there was one already active (initialized), and to check if there was one already waiting to be activated (update available). I built this check into the checkForUpdates hooks so it comes bundled with all the service worker hooks.

**Second lesson learned**: Using the callbacks in the service-worker files requires something like `redux` that lives outside the app state. I initially tried to get this working with React Context but because the callbacks need to be registered outside the render cycle then this approaoch isn't really doable. 

You *could* use React Context but you'd end up just working lots directly with the `navigator.serviceWorker` api...which isn't the worst thing tbh, but kinda negates the point of using the service-worker files from this CRA template. (again, point of this project was to use those files as much as possible! you absolutely could build something using React Context that ignores the callbacks and does its own thing...but that's a separate project for me).

**Third lesson learned**: You gotta test this with the app built in production mode, and you gotta use an incognito window when testing.

You *can* do conditional changes in the service worker files so they can run in react dev mode but I don't recommend it because it can make it easy to lose track of what's going on. In dev mode (`npm start`), when you change files then it updates in the browser automagically...which can be deceptive and confusing *directly because* it contradicts the process of having web workers decide what update the browser serves to the user. Web workers are installed, waiting, then activated...If you have an active service worker and then update your code, you'll then have an active service worker serving the old code and a new service worker waiting to be activated. Unless you do a *hard* refresh (e.g. `CTRL-SHIFT-R` in Windows / `CMD-SHIFT-R` in Mac), or close *all open tabs* those service workers will stick around. (or unless you f**k with the dev tools and check the "Update on reload" button so soft refresh acts like hard refresh)

Anyway, all this can really muddle the f**k out of learning how this works. So if running `npm run build && serve -s build` is too inconvenient, then just create a script like I've done! It'll keep you sane.

**Lesson four**...THERE'S ACTIVE BUG in Chrome that doesn't show service worker update requests in the network tab >:|

https://bugs.chromium.org/p/chromium/issues/detail?id=1335463

So if you are updating your service worker in the Dev Tools and not seeing updates in the network tab (to fetch the serviceworker.js file) then this is why. You are *supposed* to see it there, but you won't...on the plus side, if you *are* serving the app like I recommend above, then you *will* see this request logged by the server! :D

Lesson five: Yes, changes to the source files do trigger changes to the serviceworker.js file...because of workbox. >:D

I'd read that what triggers an "update" in a service worker lifecycle is when the hash of the registered serviceworker.js file (or whatever the f**k url you pass to `navigator.serviceWorker.register`) changes. 

Which confused the hell out me because...I care about updates to my source code! I shouldn't ever have to update the service-worker.js file directly just to trigger an update to clients? 

I went down a rabbit hole and realized that changes to the service-worker.js file included its imports...which means simply importing e.g. a version.js file or something could trigger it...But that seems super silly to do. What if I forget to update that file after a source code change? 

And yet...with the f**kery of playing around with the service-worker files provided by the CRA template, my service workers were being triggered to update when I changed e.g. App.js or any other parts of my source code (except for comments because the build removes those). 

Turns out (despite how ... not immediately obvious it is in their docs) those files use workbox, and the service-worker.js file uses the precacheAndRoute function, which *imports the urls of your built files*...And it turns out, the *urls of those files are tied to their file hash*. So, boom! Changes to your source code percolate into the service-worker.js file.

Their docs could be clearer on this when learning...I had to inspect the minified javascript in my browser to see/confirm this for myself (and you're definitely welcome to try that too as a learning exercise). But...that's how changes to your source code trigger service worker updates!

And that's it for now. If there are corrections I'll add them...But I wrote this mostly for me because I'm a chucklenut and will forget this in six months. Happy coding, you silly idiot! <3